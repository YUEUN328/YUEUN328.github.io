---
layout: single
title: 20일차
categories: TIL
tag: Java
author_profile: false
---

## TIL

- 

<br>

## list

```java
package edu.java.list04;

public class Score {
	// field(member variable)
	private int korean;
	private int english;
	
	// constructor
	public Score() {}
	public Score(int korean, int english) {
		this.korean = korean;
		this.english = english;
	}
	
	// getters & setters
	public int getKorean() {
		return this.korean;
	}	
	public void setKorean(int korean) {
		this.korean = korean;
	}	
	public int getEnglish() {
		return this.english;
	}
	public void setEnglish(int english) {
		this.english = english;
	}
	
	@Override
	public String toString() {
		return "Score{korean=" + this.korean + ", english=" + this.english + "}";
	}
	
	@Override // "두 점수가 같다"를 재정의
	public boolean equals(Object obj) {
		boolean result = false;
		if (obj instanceof Score) {
			Score score = (Score)obj; // casting
			if (this.korean == score.korean && this.english == score.english) {
				result = true;
			}
		}
		
		return result;
	}
	
	// equals 메서드가 true를 리턴하는 두 객체는 hashCode가 리턴하는 int 값이 같아야 됨!
	// (hashCode 값이 다르면 equals는 false를 리턴!)
	// equals 메서드가 false일 때 hashCode 값이 같아야 되는지, 달라야 되는지의 제약은 없음!
	@Override
	public int hashCode() {
		return this.korean * 10 + this.english;
	}
	
}
```

korean과 english가 int 타입이기 때문에 this.korean == score.korean 처럼 == 연산자를 쓸 수 있는 것이다. 

hashCode 메서드는 this.korean + this.english 를 리턴해도 되고, this.korean * 100 + this.english 를 리턴해도 된다. 

<br>

## set

```java
package edu.java.set01;

import java.util.Set;
import java.util.TreeSet;

/*
 * Collection<E>
 * |__ Set<E>
 * 	   |__ HashSet<E>, TreeSet<E>
 * 
 * Set<E>의 특징: 
 * 1) 중복된 값을 저장할 수 없음. (예) {1, 2, 3} = {1, 2, 2, 3, 3, 3}
 * 2) 저장하는 순서가 중요하지 않음. 인덱스가 없음! (예) {1, 2, 3} = {3, 1, 2}
 * 
 * HashSet<E>: Hash 알고리즘(검색을 빨리할 수 있는 알고리즘)을 사용한 Set(집합)
 * TreeSet<E>: Tree 알고리늠(정렬을 빨리할 수 있는 알고리즘)을 사용한 Set(집합)
 */

public class SetMain01 {

	public static void main(String[] args) {
		// String을 저장하는 TreeSet을 생성
		Set<String> set = new TreeSet<>();
		// 변수를 선언할 때 Set이 저장하는 원소 타입을 생략할 순 없지만,
		// 생성자를 호출할 때는 원소 타입을 생략할 수 있음

		System.out.println("size: " + set.size());
		System.out.println(set);

		// List<E>는 add(Object), remove(int), remove(Object), get(int), set(int, Object) 메서드를 가지고 있지만,
		// Set<E>은 add(Object), remove(Object) 메서드만 가지고 있음. 인덱스(int)를 이용하는 메서드는 없음

		// Set<E>에 원소 추가 - add
		set.add("hello");
		System.out.println("size: " + set.size());
		System.out.println(set);

		set.add("hello");
		System.out.println(set); // -> Set<E>은 중복된 값을 저장하지 않음

		set.add("apple");
		System.out.println(set);

		set.add("banana");
		System.out.println(set);
		// -> add 순서와 println에서 출력되는 원소들의 순서가 다름! 원소들이 알파벳 순서로 정렬되어 있음

		// Set<E>이 가지고 있는 원소 삭제 - remove
		set.remove("banana");
		System.out.println(set);

		// Set<E>도 향상된 for 구문을 사용할 수 있음
		// Set<E>은 for (int i = 0; i < size; i++) {} 구문을 사용할 수 없음!
		for (String s : set) {
			System.out.println(s);
		}

	}

}
```

```java
package edu.java.set02;

import java.util.HashSet;
import java.util.Set;

import edu.java.list04.Score;

public class SetMain02 {

	public static void main(String[] args) {
		// edu.java.list04.Score를 저장하는 HashSet을 생성
		// Set: 중복된(같은) 값을 저장하지 않음 add 순서가 중요하지 않음
		// HashSet:검색이 빠른 Set
		Set<Score> set = new HashSet<>();
		System.out.println(set);
		
		set.add(new Score());
		System.out.println(set);
		
		// equals()의 결과가 true이면, hashCode()의 리턴 값이 같다
		// hashCode()의 리턴 값이 다르면, equals()의 결과가 false이다
		// HashSet<E>은 원소를 추가(add)할 때, hashCode() 값이 다르면 equals 검사를 하지 않고 원소를 추가(add)함
		
		set.add(new Score(0, 0));
		System.out.println(set);
		
		set.add(new Score(100, 100));
		System.out.println(set);
		
		Score s = new Score(); // 삭제하기 위한 객체
		set.remove(s);
		System.out.println(set);
		
	}

}
```

```java
package edu.java.set03;

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

public class SetMain03 {

	public static void main(String[] args) {
		// 정수(Integer)를 저장할 수 있는 HashSet을 생성
		Set<Integer> set = new HashSet<>();
		System.out.println(set);
		
		// 0 이상 9 이하 서로 다른 난수 5개를 저장
		Random random = new Random(); // 난수를 생성하는 도구 생성
		while (true) {
			int r = random.nextInt(10); // 난수 생성
			System.out.println(r); 
			set.add(r); // 난수를 set에 추가(다른 숫자이면 추가되고, 같은 숫자이면 추가되지 않음)
			System.out.println(set);
			
			if (set.size() == 5) { // set의 원소의 개수가 5개이면
				break; // 무한 루프 종료
			}
		}
		
	}

}
```

<br>

## 과제

연락처 프로그램 ver 0.3

```java
package edu.java.contact.menu;

public interface MainMenu {
	// Main view(메인 클래스)에서 필요한 기능들 정의
	int QUIT = 0; 			 // 프로그램 종료
	int SELECT_ALL = 1; 	 // 연락처 목록 전체 검색
	int SELECT_BY_INDEX = 2; // 인덱스로 연락처 1개 정보 검색
	int INSERT = 3; 		 // 새 연락처 추가
	int UPDATE = 4;		 	 // 연락처 정보(이름, 전화번호, 이메일) 업데이트
	int DELETE = 5; 		 // 연락처 삭제
}
```

```java
package edu.java.contact.ver03;

import java.util.List;

import edu.java.contact.model.Contact;

// MVC 아키텍쳐에서 Controller 인터페이스 - DAO(Data Access Object)
public interface ContactDao {
	
	/**
	 * 리스트에 저장된 연락처 정보를 리턴.
	 * 
	 * @return - 연락처 정보가 저장된 리스트.
	 */
	List<Contact> select();
	
	/**
	 * 인덱스에 해당하는 배열의 원소(Contact 객체)를 리턴.
	 * 
	 * @param index - 0 이상의 정수. 검색할 연락처의 인덱스.
	 * @return - index에 있는 Contact 객체. index가 리스트 범위 밖이면 null을 리턴. 
	 */
	Contact select(int index);
	
	/**
	 * Contact 객체를 전달받아서 리스트에 저장.
	 * 
	 * @param c - 리스트에 저장할 Contact 타입 객체.
	 * @return - 리스트에 연락처 저장을 성공하면 1, 실패하면 0을 리턴.
	 */
	int insert(Contact c);
	
	/**
	 * 리스트에서 업데이트할 데이터의 인덱스(index)와 업데이트할 정보(Contact 타입 객체)를 전달받아서,
	 * 리스트의 해당 인덱스 위치의 연락처 정보를 업데이트.
	 * 
	 * @param index - 0 이상의 정수. 리스트에서 업데이트할 연락처의 인덱스. 
	 * @param contact - Contact 타입 객체. 업데이트할 이름, 전화번호, 이메일 정보를 가지고 있음.
	 * @return - 업데이트 성공하면 1, 실패하면 0을 리턴.
	 */
	int update(int index, Contact contact);
	
	/**
	 * 리스트에서 index 위치에 있는 연락처 정보를 삭제.
	 * 
	 * @param index - 0 이상의 정수. 리스트에서 삭제할 연락처의 인덱스.
	 * @return - 삭제 성공하면 1, 실패하면 0을 리턴.
	 */
	int delete(int index);

}
```

```java
package edu.java.contact.ver03;

import java.util.ArrayList;
import java.util.List;

import edu.java.contact.model.Contact;

public class ContactDaoImpl implements ContactDao {
	// field(멤버 변수)
	private List<Contact> contacts = new ArrayList<>(); // 연락처 정보를 저장할 리스트

	// singleton
	private static ContactDaoImpl instance = null;
	private ContactDaoImpl() {}
	public static ContactDaoImpl getInstance() {
		if (instance == null) {
			instance = new ContactDaoImpl();
		}
		return instance;
	}

	@Override
	public List<Contact> select() {
		return contacts;
	}

	@Override
	public Contact select(int index) {
		Contact result = null;
		if (index >= 0 && index < contacts.size()) { // 파라미터 index가 리스트의 인덱스 범위 안에 있으면
			result = contacts.get(index);
		}

		return result;
	}

	@Override
	public int insert(Contact c) {
		contacts.add(c);

		return 1;
	}

	@Override
	public int update(int index, Contact contact) {
		int result = 0;
		if (index >= 0 && index < contacts.size()) { // 파라미터 index가 배열의 인덱스 범위 안에 있으면
			contacts.set(index, contact);
//			contacts.get(index).setName(contact.getName());
//			contacts.get(index).setPhone(contact.getPhone());
//			contacts.get(index).setEmail(contact.getEmail());
			result = 1;
		}

		return result;
	}

	@Override
	public int delete(int index) {
		int result = 0;
		if (index >= 0 && index < contacts.size()) {
			contacts.remove(index);
			result = 1;
		}

		return result;
	}

}
```

```java
package edu.java.contact.ver03;

import static edu.java.contact.menu.MainMenu.*;

import java.util.List;
import java.util.Scanner;

import edu.java.contact.model.Contact;

public class ContactMain03 {
	private static Scanner scanner = new Scanner(System.in);
	private static ContactDao dao = ContactDaoImpl.getInstance();

	public static void main(String[] args) {
		System.out.println("*** 연락처 프로그램 ver 0.3 ***");

		boolean run = true;
		while (run) {
			int menu = chooseMenu();
			switch (menu) {
			case QUIT:
				run = false;
				break;
			case SELECT_ALL:
				selectAllContacts();
				break;
			case SELECT_BY_INDEX:
				selectContactByIndex();
				break;
			case INSERT:
				insertNewContact();
				break;
			case UPDATE:
				updateContactInfo();
				break;
			case DELETE:
				deleteContactByIndex();
				break;
			default:
				System.out.println("다시 선택하세요...");
			} // end switch

		} // end while

		System.out.println("*** 프로그램 종료 ***");
	}

	private static void deleteContactByIndex() {
		System.out.println();
		System.out.println("--- 연락처 정보 삭제 ---");
		System.out.println("삭제할 인덱스>>");
		int index = inputInteger();
		int result = dao.delete(index);
		if (result == 1) {
			System.out.println("삭제 성공!!!");
		} else {
			System.out.println("삭제 실패...");
		}
	}

	private static void updateContactInfo() {
		System.out.println();
		System.out.println("--- 연락처 정보 수정 ---");
		System.out.println("수정할 인덱스>>");
		int index = inputInteger();
		System.out.println("이름 수정>>");
		String name = scanner.nextLine();
		System.out.println("전화번호 수정>>");
		String phone = scanner.nextLine();
		System.out.println("이메일 수정>>");
		String email = scanner.nextLine();

		Contact contact = new Contact(name, phone, email);
		int result = dao.update(index, contact);
		if (result == 1) {
			System.out.println("연락처 정보 수정 성공!!!");
		} else {
			System.out.println("연락처 정보 수정 실패...");
		}
	}

	private static void insertNewContact() {
		System.out.println();
		System.out.println("--- 새 연락처 추가 ---");
		System.out.println("이름 입력>>");
		String name = scanner.nextLine();
		System.out.println("전화번호 입력>>");
		String phone = scanner.nextLine();
		System.out.println("이메일 입력>>");
		String email = scanner.nextLine();

		Contact contact = new Contact(name, phone, email);
		int result = dao.insert(contact);
		if (result == 1) {
			System.out.println("새 연락처 추가 성공!!!");
		} else {
			System.out.println("새 연락처 추가 실패...");
		}
	}

	private static void selectContactByIndex() {
		System.out.println();
		System.out.println("--- 인덱스 검색 ---");
		System.out.println("검색할 인덱스>>");
		int index = inputInteger();

		Contact contact = dao.select(index);
		if (contact != null) {
			System.out.println(contact);

		} else {
			System.out.println("입력한 인덱스에는 연락처 정보가 없습니다.");
		}
	}

	private static void selectAllContacts() {
		System.out.println();
		System.out.println("--- 연락처 전체 리스트 ---");
		List<Contact> contactList = dao.select();
		System.out.println(contactList);
		System.out.println("--------------------------");
	}

	private static int chooseMenu() {
		showMainMenu();
		int menu = inputInteger();

		return menu;
	}

	private static int inputInteger() {
		while (true) {
			String s = scanner.nextLine();
			try {
				int n = Integer.parseInt(s);
				return n;
			} catch (NumberFormatException e) {
				System.out.println("입력한 값은 정수가 아닙니다. 다시 입력하세요>>");
			}
		}
	}

//	private static int inputInteger() {
//		String s = scanner.nextLine();
//		try {
//			int n = Integer.parseInt(s);
//			return n;
//		} catch (NumberFormatException e) {
//			System.out.println("입력한 값은 정수가 아닙니다.");
//			return -1;
//		}
//	}

	private static void showMainMenu() {
		System.out.println();
		System.out.println("-----------------------------------------------------------------");
		System.out.println("[1] 전체 검색 [2] 인덱스 검색 [3] 추가 [4] 수정 [5] 삭제 [0] 종료");
		System.out.println("-----------------------------------------------------------------");
		System.out.println("선택>>");
	}

} // end class ContactMain03
```

inputInteger 메서드를 쓸 생각을 못 했다. 메서드를 쓰니까 이렇게 간편해지는데!

반복되는 코드가 있다면 메서드를 만들자!!!
